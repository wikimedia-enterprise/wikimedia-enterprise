package resolver

import (
	"fmt"
	"strings"
)

const wildcard = "*"

// NewSelect creates new select statement using struct resolver,
// simplifies SQL generation for ksqldb query.
func NewSelect(rvr *Resolver, fields []string, table ...string) *Select {
	s := &Select{
		rvr:       rvr,
		Wildcards: []string{},
		Fields:    map[string]struct{}{},
		Omit: map[string]struct{}{
			"event":       {},
			"in_language": {},
		},
	}

	for _, field := range fields {
		name := field

		if len(table) > 0 {
			if !strings.HasPrefix(field, fmt.Sprintf("%s.", table[0])) {
				continue
			}

			name = field[len(fmt.Sprintf("%s.", table[0])):]
		}

		path := ""

		for _, name := range strings.Split(name, ".") {
			if name == wildcard {
				s.Wildcards = append(s.Wildcards, strings.TrimSuffix(path, "."))
			}

			path += fmt.Sprintf("%s.", name)
			s.Fields[strings.TrimSuffix(path, ".")] = struct{}{}
		}
	}

	return s
}

// Select helper for SQL generation.
type Select struct {
	rvr       *Resolver
	Wildcards []string
	Fields    map[string]struct{}
	Omit      map[string]struct{}
}

// GetSql generates SQL for SELECT part of the query.
// Uses fields structure generated by resolver.
func (s *Select) GetSql() string {
	sql := ""

	if len(s.Fields) <= 0 {
		return sql
	}

	_, wc := s.Fields[wildcard]

	sfr := func(fld *Field) bool {
		if _, ok := s.Omit[fld.Name]; ok {
			return false
		}

		_, ok := s.Fields[fld.FullName]

		for _, wc := range s.Wildcards {
			if strings.HasPrefix(fld.FullName, wc) {
				return true
			}
		}

		return wc || ok
	}

	ffr := func(fld *Field) bool {
		_, ok := s.Fields[fld.Name]
		return wc || ok
	}

	if val := s.rvr.GetFieldsSql(ffr); len(val) > 0 {
		sql += val
	}

	if val := s.rvr.GetStructsSql(sfr); len(val) > 0 {
		sql += fmt.Sprintf(", %s", val)
	}

	if val := s.rvr.GetSlicesSql(sfr); len(val) > 0 {
		sql += fmt.Sprintf(", %s", val)
	}

	return strings.TrimPrefix(sql, ", ")
}
