// This file is to be removed soon.
package resolver

import (
	"fmt"
	"strings"
)

const wildcard = "*"

// Filter provides the ability to filter out sql generated by resolver.
type Filter func(fld *Field) bool

// GetFilter get unified filter from list of filters.
func GetFilter(filters ...Filter) Filter {
	return func(fld *Field) bool {
		for _, fr := range filters {
			if fr(fld) {
				return true
			}
		}

		return len(filters) == 0
	}
}

// GetFieldsSQL generate SQL query for fields.
func (r *Resolver) GetFieldsSql(filters ...Filter) string {
	sql := ""
	fr := GetFilter(filters...)

	for name, fld := range r.Struct.Fields {
		if _, ok := r.Struct.Structs[name]; !ok && fr(fld) {
			sql += fmt.Sprintf("%s, ", fld.Path)
		}
	}

	return strings.TrimSuffix(sql, ", ")
}

// GetStructsSQL generate SQL query for structs.
func (r *Resolver) GetStructsSql(filters ...Filter) string {
	sql := ""
	fr := GetFilter(filters...)

	for _, str := range r.Struct.Structs {
		if val := str.GetSql(fr); len(val) > 0 {
			sql += fmt.Sprintf("%s, ", val)
		}
	}

	return strings.TrimSuffix(sql, ", ")
}

// GetSlicesSql generate SQL query for slices.
func (r *Resolver) GetSlicesSql(filters ...Filter) string {
	sql := ""
	fr := GetFilter(filters...)

	for _, slc := range r.Struct.Slices {
		if val := slc.GetSql(fr); len(val) > 0 {
			sql += fmt.Sprintf("%s, ", val)
		}
	}

	return strings.TrimSuffix(sql, ", ")
}

// GetSql get generated SQL statement for struct. Gives us
// the ability to dynamically resolve and specify fields.
// TODO - Add support for slices inside low level structs.
func (s *Struct) GetSql(filter Filter) string {
	sql := ""

	for name, fld := range s.Fields {
		if _, ok := s.Structs[name]; !ok && filter(fld) {
			sql += fmt.Sprintf("%s := %s, ", fld.Name, fld.Path)
		}
	}

	for _, str := range s.Structs {
		if filter(str.Field) {
			if val := str.GetSql(filter); len(val) > 0 {
				sql += fmt.Sprintf("%s := %s, ", str.Field.Name, val)
			}
		}
	}

	if len(sql) == 0 {
		return ""
	}

	if s.IsRoot {
		return fmt.Sprintf("STRUCT(%s) as %s", strings.TrimSuffix(sql, ", "), s.Field.Path)
	}

	return fmt.Sprintf("STRUCT(%s)", strings.TrimSuffix(sql, ", "))
}

// GetSql generates SQL query (for SELECT statement) for mapping struct
// fields to ksqldb query.
func (s *Slice) GetSql(filter Filter) string {
	sql := ""

	for name, fld := range s.Struct.Fields {
		if _, ok := s.Struct.Structs[name]; !ok && filter(fld) {
			sql += fmt.Sprintf("%s := %s, ", fld.Name, strings.ReplaceAll(fld.FullName, ".", "->"))
		}
	}

	if len(sql) == 0 {
		return ""
	}

	return fmt.Sprintf("TRANSFORM(%[1]s, x => STRUCT(%[2]s)) as %[3]s",
		s.Struct.Field.Path,
		strings.ReplaceAll(strings.TrimSuffix(sql, ", "), s.Struct.Field.Path, "x"),
		s.Struct.Field.Name,
	)
}

// NewSelect creates new select statement using struct resolver,
// simplifies SQL generation for ksqldb query.
func NewSelect(rvr *Resolver, fields []string, table ...string) *Select {
	s := &Select{
		rvr:       rvr,
		Wildcards: []string{},
		Fields:    map[string]struct{}{},
		Omit: map[string]struct{}{
			"event":       {},
			"in_language": {},
		},
	}

	for _, field := range fields {
		name := field

		if len(table) > 0 {
			if !strings.HasPrefix(field, fmt.Sprintf("%s.", table[0])) {
				continue
			}

			name = field[len(fmt.Sprintf("%s.", table[0])):]
		}

		path := ""

		for _, name := range strings.Split(name, ".") {
			if name == wildcard {
				s.Wildcards = append(s.Wildcards, strings.TrimSuffix(path, "."))
			}

			path += fmt.Sprintf("%s.", name)
			s.Fields[strings.TrimSuffix(path, ".")] = struct{}{}
		}
	}

	return s
}

// Select helper for SQL generation.
type Select struct {
	rvr       *Resolver
	Wildcards []string
	Fields    map[string]struct{}
	Omit      map[string]struct{}
}

// GetSql generates SQL for SELECT part of the query.
// Uses fields structure generated by resolver.
func (s *Select) GetSql() string {
	sql := ""

	if len(s.Fields) <= 0 {
		return sql
	}

	_, wc := s.Fields[wildcard]

	sfr := func(fld *Field) bool {
		if _, ok := s.Omit[fld.Name]; ok {
			return false
		}

		_, ok := s.Fields[fld.FullName]

		for _, wc := range s.Wildcards {
			if strings.HasPrefix(fld.FullName, wc) {
				return true
			}
		}

		return wc || ok
	}

	ffr := func(fld *Field) bool {
		_, ok := s.Fields[fld.Name]
		return wc || ok
	}

	if val := s.rvr.GetFieldsSql(ffr); len(val) > 0 {
		sql += val
	}

	if val := s.rvr.GetStructsSql(sfr); len(val) > 0 {
		sql += fmt.Sprintf(", %s", val)
	}

	if val := s.rvr.GetSlicesSql(sfr); len(val) > 0 {
		sql += fmt.Sprintf(", %s", val)
	}

	return strings.TrimPrefix(sql, ", ")
}
