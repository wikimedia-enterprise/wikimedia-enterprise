// Package tokenrevoke is intended to take away access all access tokens generated by a refresh token.
package tokenrevoke

import (
	"errors"
	"fmt"
	"net/http"
	"wikimedia-enterprise/api/auth/config/env"
	"wikimedia-enterprise/api/auth/submodules/httputil"
	"wikimedia-enterprise/api/auth/submodules/log"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/cognitoidentityprovider"
	"github.com/aws/aws-sdk-go/service/cognitoidentityprovider/cognitoidentityprovideriface"
	"github.com/gin-gonic/gin"
	"github.com/go-redis/redis/v8"
	"go.uber.org/dig"
)

// Parameters dependency injection for the handler.
type Parameters struct {
	dig.In
	Cognito cognitoidentityprovideriface.CognitoIdentityProviderAPI
	Env     *env.Environment
	Redis   redis.Cmdable
}

// Model structure represents input data format.
type Model struct {
	RefreshToken string `json:"refresh_token" form:"refresh_token" binding:"required"`
}

var (
	// Here, "internal" means the error is on our side (Wikimedia Enterprise), not necessarily in the auth API server.
	internalErr = errors.New("Internal error, please try again later.")
)

// NewHandler creates new revoke HTTP handler.
func NewHandler(p *Parameters) gin.HandlerFunc {
	return func(gcx *gin.Context) {
		mdl := new(Model)

		if err := gcx.ShouldBind(mdl); err != nil {
			log.Error(err, log.Tip("problem in revoke user v1 binding inputs"), log.Any("url", gcx.Request.URL.String()))
			httputil.UnprocessableEntity(gcx, internalErr)
			return
		}

		_, err := p.Cognito.RevokeTokenWithContext(gcx.Request.Context(), &cognitoidentityprovider.RevokeTokenInput{
			ClientId:     aws.String(p.Env.CognitoClientID),
			ClientSecret: aws.String(p.Env.CognitoSecret),
			Token:        aws.String(mdl.RefreshToken),
		})

		if err != nil {
			log.Error(err, log.Tip("problem in v1 revoke user is unauthorized"))
			httputil.Unauthorized(gcx)
			return
		}

		var cursor uint64
		var refreshTokens []string

		for {
			var tokens []string

			tokens, cursor, err = p.Redis.Scan(
				gcx.Request.Context(),
				cursor,
				fmt.Sprintf("refresh_token:*:%s:access_tokens", mdl.RefreshToken),
				10,
			).Result()

			if err != nil {
				log.Error(err, log.Tip("problem in v1 revoke user, redis scan failed"))
				httputil.InternalServerError(gcx, internalErr)
				return
			}

			refreshTokens = append(refreshTokens, tokens...)

			if cursor == 0 {
				break
			}
		}

		var deleteKeys []string

		for _, refreshToken := range refreshTokens {
			tokens, err := p.Redis.SMembers(gcx.Request.Context(), refreshToken).Result()

			if err != nil {
				log.Error(err, log.Tip("problem in v1 revoke user, redis SMembers returned nil"))
				httputil.InternalServerError(gcx, internalErr)
				return
			}

			for _, token := range tokens {
				deleteKeys = append(deleteKeys, fmt.Sprintf("access_token:%s", token))
			}

			deleteKeys = append(deleteKeys, refreshToken)
		}

		if len(deleteKeys) > 0 {
			if err := p.Redis.Del(gcx.Request.Context(), deleteKeys...).Err(); err != nil {
				log.Error(err, log.Tip("problem in v1 revoke user, redis delete failed"))
				httputil.InternalServerError(gcx, internalErr)
				return
			}
		}

		gcx.Status(http.StatusNoContent)
	}
}
